## 设计模式

2020年1月15日完结，后需复习，源码分析

### 面向对象设计原则

#### 面向对象设计模式常用七大原则

核心思想：

- 找出应用中可能需要变化之处，独立出来；
- 针对接口编程，不是针对实现编程；
- 交互对象之间松耦合

代码重用性、可读性、可扩展性、可靠性、高内聚低耦合

##### 单一职责

一个类只负责一项指责（逻辑足够简单的情况下，可以违反单一原则，在类方法少的情况下可以仅方法层面实现单一原则）

- 降低类的复杂度，一个类仅负责一项指责
- 提高类的可读性可维护性
- 降低变更引起的风险

##### 接口隔离

客户端不应该依赖不需要的接口，一个类对另一个类的依赖建立在最小接口上

传递接口实际是传递接口的方法

##### 依赖倒转

- 高层模块不应依赖底层模块，二者应该依赖抽象
- 抽象不应依赖细节，细节应该依赖抽象
- 依赖倒置原则：面向接口编程
- 抽象稳定，所以以抽象搭建的架构比细节搭建的架构更加稳定
- 接口和抽象类的目的是指定好规则，不涉及具体的操作

##### 里氏替换

继承：父类以实现的方法，是在设定规范和契约，不强制要求所有子类必须遵守契约，但是子类对已经实现的方法进行修改，会对继承体系造成破坏。当父类修改后，所有涉及到子类的功能都可能产生故障。

所有引用基类的地方必须能透明地使用子类的对象（把父类换成子类不会对程序产生影响，）

**子类尽量不要重写父类的方法，可以考虑两个类继承同一个基类，降低两个类的耦合性**

（组合：A为B类中的属性，在B类中用A a = new A() ;然后使用a的方法）

待补充：java类与类的五种关系

##### 开闭原则OCP（核心）

对扩展开放（对拓展方），对修改关闭（对使用方）：

用抽象构建框架，用实现扩展细节，通过扩展来实现变化，不是修改原有代码



##### 迪米特法则（最少知道原则）--

核心：降低类与类之间的耦合

对象应该对其他对象保持最少的了解，

类与类关系越密切，耦合度越大，

一个类对自己依赖的类知道的越少越好，对除了提供的public方法，不对外泄露任何信息

直接朋友：成员变量，方法参数，方法返回值中的类为直接的朋友，

**陌生的类最好不要以局部变量的形式出现在类的内部**

###### 只调用陌生类的方法，不是先依赖于陌生类的逻辑



##### 合成复用原则

尽量使用合成/聚合的方式，而不是使用继承

B类使用A类的方法，使用继承会使耦合性过于强，使用其他关系替换

- 方法参数（依赖）
- B类的属性
- - 直接创建（A a = new a()组合）
  - 使用时创建（A a； set(a)聚合）

### UML

#### 一、基本介绍

UML：统一建模语言，用于软件系统分析和设计的语言工具

是一套符号规定，用于描述软件模型中的各个元素和他们之间的关系。

接口、

类、

实现、

泛化、

依赖、

关联

组合、

聚合等



### 设计模式

#### 一、单例模式--一个类仅一个实例对象

##### 实现思路

- 私有化构造方法
- 提供公有的实例对象
- 实例对象为类中静态属性

##### 具体实现

###### 懒汉式--调用方法时初始化对象

```java
/**
 * 单例模式--懒汉式
 */
public class Lazy {
    //类实例为静态属性
    private static Lazy instance;
    //私有构造函数
    private Lazy (){}

    //公有的提供静类实例的方法
    public static Lazy getInstance(){
        if(instance == null){
            instance =  new Lazy();
        }
        return instance;
    }
}
```

特点：时间换空间，调用时候才初始化，线程不安全，多线程情况下不是严格意义上的单例模式。

###### 饿汉式--类加载就初始化对象

```java
/**
 * 单例模式--饿汉式
 */
public class Hungry {
    //类实例对象为静态属性
    //类初始化就实例对象
    private static Hungry instance = new Hungry();
    //私有构造函数
    private Hungry(){}
    //公有的提供静类实例的方法
    public static Hungry getInstance(){
        return instance;
    }
}
```

特点：空间换时间，类加载就创建对象，没有线程问题。

##### 解决懒汉式 的线程安全问题

###### 法一、getInstance()方法加synchronized 锁 ，

线程安全，但由于每次都要判断，所以效率低

###### 法二、双重检查加锁

```java
public class Singleton {
	
	    // 实例对象为静态属性
		private static volatile Singleton instance = null;
 
	    // 私有化构造函数
    	private Singleton() {
		};
 
		//公有的提供静类实例的方法
		public static Singleton getInstance() {
			// 第一次判空。
			if (instance == null) {
				// 加锁（多线程情况可能不止一个线程在等锁）
				synchronized (Singleton.class) {
					// 所以需要第二次判空。
					if (instance == null) {
						instance = new Singleton();
					}
				}
			}
			return instance;
		}
}
```

#### 二、工厂模式

pizza案例：披萨种类很多，不同种披萨制作流程固定

传统方法：违反了ocp原则

![1576587738492](typora_picture\PizzaUML.png)

##### 简单工厂模式

简单工厂模式：把创建pizza 的过程封装到一个类中，有新的pizza种类时仅修改该类即可

由工厂对象决定创建对象实例，定义一个创建对象的类（工厂类），把实例化对象的行为封装起来

![1576587738492](typora_picture\简单工厂UML.png)

##### 工厂方法模式

需求：披萨有口味不同，还有地区的不同

介绍：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现

工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。

工厂方法模式**将对象的实例化推迟到子类**

![1576587738492](typora_picture\工厂方法UML.png)

##### 抽象工厂模式

抽象工厂模式定义了一个interface用于创建相关或有依赖的对象族，而无需指明具体的类、

抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。

从设计层面看，抽象工厂模式就是对简单工厂模式的改进

将工厂抽象成两层，抽象工厂 和 具体实现的工厂子类，程序员可以根据创建对象类型使用对应的工厂子类，这样将单个的简单工厂类变成了工厂族，更利于代码的维护和扩展

![1576587738492](typora_picture\抽象工厂UML.png)



#### 三、原型模式

提出：创建10只属性完全相同的羊

基础方案：

```java
//传统方式
Sheep sheep = new Sheep("tom", 1, "白色");
        Sheep sheep1 = new Sheep(sheep.getName(),sheep.getAge(),sheep.getColor());
        Sheep sheep2 = new Sheep(sheep.getName(),sheep.getAge(),sheep.getColor());

```

原型模式：用原型实例指定创建对象的种类，并且通过拷贝原型创建新的对象；原型模式是一种创建型设计模式，允许一个对象再 创建另外一个可定制的对象，无需知道创建的细节；

工作原理：将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝他们自己来创建实例，对象.clone()

![1576587738492](typora_picture\原型模式UML.png)

Prototype：原型类，生命一个克隆自己的接口

concreteProtptype：具体的原型类，实现克隆自己的操作

client：让原型对象克隆自己，从而创建一个新的对象

可以用于bean多例的实现

//浅拷贝：基本数据类型：值传递
//		引用数据类型：引用传递

```java
//浅拷贝：基本数据类型：值传递
//		引用数据类型：引用传递
protected Object clone() {
        Sheep sheep = null;
        try{sheep = (Sheep)super.clone();
        }catch (Exception e){
            System.out.println(e.getMessage());
        }
         return sheep;
    }
```

//深拷贝：引用类型申请储存空间

```java
//深拷贝-方式1使用clone方法
    @Override
    protected  Object clone () throws CloneNotSupportedException {
        Object deep = null;
        deep = super.clone();
        //对引用类型的属性进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType) deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();
        return deep;
    }

//深拷贝-方式2通过对象的序列化实现（推荐）
    public Object deepClone(){

        //创建对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try{
            //序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            //反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copyObj = (DeepProtoType) ois.readObject();
            return copyObj;
        }catch (Exception e){
            System.out.println(e);
            return null;
        }finally {
            try{
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            }catch (Exception e){
                System.out.println(e);
            }
        }

    }
```

#### 四、建造者模式

案例：需要建房子，过程为打桩、砌墙、封顶；房子各种各样的，过程一样，但是要求不同

传统方式：

![1576587738492](typora_picture\盖房子UML.png)

问题：把产品和创建产品的过程封装在以前，耦合性强，扩展性差

解决：将产品和产品建造过程解耦==》建造者模式

建造者模式（生成器模式）：是一种对象构建模式。将复杂对象的建造过程抽下那个出来，使抽象过程的不同实现方法可以构造出不同的对象；使一步一步创建一个复杂的对象，允许用户只通过执行复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节

四个角色：

- product：具体的产品对象
- builder：抽象建造者，创建product对象的各个部件
- concreteBuilder：具体建造者，实现builder
- director：指挥者，用于创建复杂的对象。有两个作用：隔离了客户与对象的生产过程、负责控制产品对象的生产过程。

![1576587738492](typora_picture\构建者模式UML.png)

![1576587738492](typora_picture\构建者模式盖房子UML.png)







Builder

```java
public abstract class HouseBuilder {

    protected House house= new House();

    public abstract void buildBasic();
    public abstract void buildWalls();
    public abstract void roofed();

    public House buildHouse(){
        return house;
    }
}

```

Product

```java
public class House {
    private String baise;
    private String wall;
    private String roofed;
    public String getBaise(){
        return baise;
    }

    public String getWall() {
        return wall;
    }

    public String getRoofed(){
        return roofed;
    }

    public void setRoofed(String roofed) {
        this.roofed = roofed;
    }

    public void setBaise(String baise) {
        this.baise = baise;
    }

    public void setWall(String wall) {
        this.wall = wall;
    }
}
```

Director

```java
public class HouseDirector {
    HouseBuilder houseBuilder = null;
    //构造器传入
    public HouseDirector(HouseBuilder houseBuilder){
        this.houseBuilder = houseBuilder;
    }

    //通过setter传入
    public void setHouseBuilder(HouseBuilder houseBuilder){
        this.houseBuilder = houseBuilder;
    }

    //处理建造房子的流程
    public House construceHouse(){
        houseBuilder.buildBasic();
        houseBuilder.buildWalls();
        houseBuilder.roofed();
        return houseBuilder.buildHouse();
    }
}
```

ConcreteBuilder

```java
public class CommonHouse extends HouseBuilder {
    public void buildBasic() {
        System.out.println("给普通房子打地基5m");
    }

    public void buildWalls() {
        System.out.println("给普通房子砌墙");
    }

    public void roofed() {
        System.out.println("给普通房子盖房顶");
    }
}

```

ConcreteBuilder

```java
public class HighBuilding extends HouseBuilder {
    public void buildBasic() {
        System.out.println("高楼地基100");
    }

    public void buildWalls() {
        System.out.println("高楼墙10cm");
    }

    public void roofed() {
        System.out.println("高楼屋顶");
    }
}
```

客户端

```java
public class Client {
    public static void main(String[] args) {
        CommonHouse commonHouse = new CommonHouse();
        HouseDirector houseDirector = new HouseDirector(commonHouse);
        House house = houseDirector.construceHouse();


        //建高楼，用set传参
        HighBuilding highBuilding = new HighBuilding();
	 houseDirector.setHouseBuilder(hIghBuilding);
        house = houseDirector.construceHouse();

    }
}

```

建造者之间相对独立，新的建造者无需修改原有类库，符合开闭结合

注意：差异性很大的不适合使用建造者模式

抽象工厂和建造者模式的区别：

抽象工厂模式实现对产品家族的创建，一个产品加载是具有不同分类未读的产品组合采用抽象工厂模式不需要关系构建过程，只关心由什么工厂生产，

构建者模式要求按照指定的蓝图构建产品，主要目的是通过组装零配件而产生新产品

#### 五、适配器模式（adapter pattern）

例子：不同国家的插座的标准是不一样的，一个多功能转换插头（适配器）可以解决这个问题。

配适器模式：将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性。让原本因接口不匹配不能一起工作的两个类可以协同工作，别名：包装器（Wrapper）

适配器属于结构型模式

主要分为：类配适器模式、对象适配器模式、接口适配器模式

src--Adapter-->dst

###### 类适配器模式：

通过集成src，实现dst类接口，完成src->dst的配适

![1576587738492](typora_picture\类适配器UML.png)



```java
/**
 * 被适配的类
 */
public class Voltage220V {
    public int output220V(){
        int src = 220;
        System.out.println("电压=" + src + "V");
        return src;
    }
}
```

```java
/**
 * 目标类
 */
public interface IVoltage5V {
    public int output5V();
}
```

```java
/**
 * 适配接口
 */
public class VoltageAdapter extends Voltage220V implements IVoltage5V  {

    public int output5V() {
        int srcV = output220V();
        int dstV = srcV/44;
        System.out.println("输出" + dstV);
        return dstV;
    }
}
```

```java
/**
 * 手机类
 */
public class Phone {
    public void charging(IVoltage5V iVoltage5V){
        if(iVoltage5V.output5V() == 5){
            System.out.println("充电");
        }
        else{
            System.out.println("不能充电");
        }
    }
}
```

```java
/**
 * 客户端类
 */
public class Client {
    public static void main(String[] args) {
        Phone p = new Phone();
        p.charging(new VoltageAdapter());
    }
}
```

###### 对象适配器模式

持有src类，实现dst类接口（符合合成复用原则(使用组合代替继承)），且由于java的单继承，少了对src的继承，可以不用限定dst必须是接口

![1576587738492](typora_picture\类适配器UML.png)

```java
/**
 * 对象适配器类，将依赖变为属性
 */
public class VoltageAdapter2 implements IVoltage5V {
    private Voltage220V voltage220V;
    public VoltageAdapter2(Voltage220V voltage220V){
        this.voltage220V = voltage220V;
    }
    public int output5V() {
        int srcV = voltage220V.output220V();
        int dstV = srcV/44;
        System.out.println("输出" + dstV);
        return dstV;
    }
}
```

```java
/**
 * 客户端类
 */
public class Client {
    public static void main(String[] args) {
        Phone p = new Phone();
        p.charging(new VoltageAdapter2(new Voltage220V()));
    }
}
```

###### 接口适配器模式（缺省适配器模式）

当不需要全部实现接口提供的方法的时候，可以设置一个抽象类，并为接口中的每个方法设置默认实现（空方法），该抽象类的子类，可以选择覆盖父类的某些方法来实现需求

适用于不需要使用接口的所有方法的情况

蛋蛋：抽象类不一定有抽象方法

![1576587738492](typora_picture\接口适配器UML.png)

```java
/**
 * 有很多方法的接口
 */
public interface Interface4 {
    public void method1();
    public void method2();
    public void method3();
    public void method4();
}
```

```java
/**
 * 空实现了接口全部方法的抽象类
 */
public abstract class AbsAdapter implements Interface4{
    public void method1() {
    }

    public void method2() {
    }

    public void method3() {
    }

    public void method4() {
    }
}
```

```java

/**
 *客户端演示
 */
public class Client {
    public static void main(String[] args) {
        //仅使用接口个别方法，通过匿名内部类方式
        AbsAdapter absAdapter = new AbsAdapter(){
            public void method1() {
                System.out.println("dandan");
            }
        };
    }
}
```

源码：springMvc的handlerAdapter

![1576587738492](typora_picture\springMVC_AdapterUML.png)



#### 六、桥接模式（bridge）

需求：不同手机类型的不同品牌实现编程（开机、关机、上网、打电话）

![1576587738492](typora_picture\桥接模式需求图.png)

![1576587738492](typora_picture\桥接模式_需求_传统UML.png)

存在问题：扩展型问题、违反单一职责原则

桥接模式：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变

基于类最小设计原则，通过使用封装聚合继承等行为让不同的类承担不同的职责，主要的特点使把抽象与行为实现分离开，从而可以保证和部分的独立性以及应对他们的功能



![1576587738492](typora_picture\桥接模式UML.png)

![1576587738492](typora_picture\桥接模式_例子UML.png)

Phone：桥，父类聚合接口，子类调用接口的实现类中的方法；两个维度分别定义2*2的效果



```java
//品牌接口
public interface Brand {
    void open();
    void close();
    void call();
}
```

```java
//vivo继承品牌，
public class Vivo implements Brand{
    public void open() {
        System.out.println("Vivo开机");
    }

    public void close() {
        System.out.println("Vivo关机");

    }

    public void call() {
        System.out.println("Vivo打电话");
    }
}
```

```java
//小米继承品牌
public class XiaoMi implements Brand{
    public void open() {
        System.out.println("小米开机");
    }

    public void close() {
        System.out.println("小米关机");

    }

    public void call() {
        System.out.println("小米打电话");
    }
}

```

```java

public class Phone {
    //组合品牌
    private Brand brand;

    //构造器
    public Phone(Brand brand){
        super();
        this.brand = brand;
    }

    protected void open() {
        brand.open();
    }

    protected void close() {
        brand.close();

    }

    protected void call() {
        brand.call();
    }
}
```

```java
//折叠手机、继承抽象类phone
public class FoldedPhone extends Phone {
    //构造器
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    @Override
    protected void open() {
        super.open();
        System.out.println("折叠手机");
    }

    @Override
    protected void close() {
        super.close();
        System.out.println("折叠手机");
    }

    @Override
    protected void call() {
        super.call();
        System.out.println("折叠手机");
    }
}
```

```java

//直立手机继承phone
public class UprightPhone extends Phone {
    public UprightPhone(Brand brand) {
        super(brand);
    }

    @Override
    protected void open() {
        super.open();
        System.out.println("直立");
    }

    @Override
    protected void close() {
        super.close();
        System.out.println("直立");
    }

    @Override
    protected void call() {
        super.call();
        System.out.println("直立");
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        //折叠式手机（样式+品牌）
        //折叠式小米
        Phone p1 = new FoldedPhone(new XiaoMi());
        p1.open();

        Phone phone = new FoldedPhone(new Vivo());
        phone.call();

        Phone phone1 = new UprightPhone(new Vivo());
        phone1.close();
    }
}
```

源码：jdbc Driver



桥接模式的注意事项和细节：

实现了抽象和实现部分的分离，从而极大地提供了系统的灵活性，让抽象部分和实现部分独立开，有助于系统进行分层设计，产生更好的结构化系统。

对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他部分由具体业务来完成

桥接模式替代多层集成方案，减少子类的个数，降低系统的管理和维护成本。

桥接模式的额引入增加了系统的理解和谁急难度，由于聚合关系建立在抽象层，要求开发者针抽象进行设计和编程

桥接模式要求正确识别系统中两个独立变化的未读，由此其实用范围有一定的局限性



应用场景：

不希望使用继承，或者应为多层次继承导致系统的个数急剧增加的系统，

常见的应用场景：

- jsbc驱动程序
- 银行转账系统
- 转账分类：网上转账、柜台转账、ATM转账
- 转账用户类型：普通用户、银卡用户、金卡用户
- 消息管理：
- 消息类型、即时消息、延时消息
- 消息分类、手机短信、邮件消息、QQ消息

#### 七、装饰者模式

###### 背景：星巴克咖啡

咖啡种类（单品）：Espresso、ShortBlack、LongBlack、Decaf

调料：Milk、Soy、Chocolate

要求在拓展新的咖啡种类时具有良好的扩展性

使用OO的来计算不同种类咖啡的费用：客户可以单点也可以加配料

###### 方案1、

类穷尽所有可能的选择方式：类爆炸

###### 方案2、

配料内置到drink中，每一种配料都是drink的属性：增删调料种类时，代码的维护量大

###### 方案3、装饰者模式

装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了OCP原则

装饰者和被装饰者均继承同一个抽象类，主体（被装饰者）作为装饰者的属性，和抽象类的关系（继承+组合）



![1576587738492](typora_picture\装饰者模式解决咖啡问题UML.png)





```java

public abstract class Drink {

    public String des;
    private float price = 0.0f;

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    //计算费用的抽象方法
    public  abstract  float cost();
}
```

```java
public class Coffee  extends  Drink{
    public float cost() {
        return super.getPrice();
    }
}

```



```java

public class Espresso extends  Coffee {

    public Espresso() {
        setDes("意大利咖啡");
        setPrice(6.0f);
    }
}
```

```java
public class LongBlack extends  Coffee {

    public LongBlack() {
        setDes("黑咖啡");
        setPrice(5.0f);
    }
}

```

```java
public class Decorator extends  Drink{
    private Drink obj;
    public float cost() {
        return super.getPrice()
                + obj.cost();
    }

    public Decorator(Drink obj) {//组合
        this.obj = obj;
    }

    @Override
    public String getDes() {
        //obj输出被装饰者信息
        return super.getDes() + ""+ super.getPrice() + ""+ obj.getDes() ;
    }
}
```

```java
public class Milk extends Decorator {
    public Milk(Drink obj) {
        super(obj);
        setDes("牛奶");
        setPrice(2.0f);
    }
}

```

```java
public class Chocolate extends  Decorator {


    public Chocolate(Drink obj) {
        super(obj);
        setDes("巧克力");
        setPrice(3.0f);//配料的价格
    }
}
```

```java
public class CoffeeBar {
    public static void main(String[] args) {
        //装饰者模式下的订单，2分巧克力+一份牛奶的Longblack
        Drink order = new LongBlack();
        System.out.println("费用=" + order.cost());
        System.out.println("描述" + order.getDes());

        //加一份牛奶
        order = new Milk(order);
        System.out.println("费用=" + order.cost());
        System.out.println("描述" + order.getDes());

        //加一分巧克力
        order = new Chocolate(order);
        System.out.println("费用=" + order.cost());
        System.out.println("描述" + order.getDes());

        //加一分巧克力
        order = new Chocolate(order);
        System.out.println("费用=" + order.cost());
        System.out.println("描述" + order.getDes());

    }
}

```

源码：InputStream

#### 八、组合模式

学校院系展示需求：页面中展示学校的院系组成，学校有多个学院，学院有多个系

关系：组合关系 学校{学院{系}}

组合模式：属于结构模式部分整体模式，创建了对象组的属性结构，将对象组合成树形结构以表示“整体部分”的层次关系

三个部分：叶子节点、非叶子节点、Organization（抽象类或者接口），

![1576587738492](typora_picture\组合模式UML.png)

需求实现：

```java
public abstract class OrganizationComponent {

    private String name;
    private String des;

    public OrganizationComponent(String name, String des) {
        this.name = name;
        this.des = des;
    }

    protected void add(OrganizationComponent organizationComponent){
        //默认实现(因为叶子节点不需要实现该方法，所以不能写成抽象方法)
        throw new UnsupportedOperationException();
    }

    protected void remove(OrganizationComponent organizationComponent){
        //默认实现(因为叶子节点不需要实现该方法，所以不能写成抽象方法)
        throw new UnsupportedOperationException();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    //所有子类都需要实现
    protected abstract void print();

}

```

```java
//就是composite（非叶子节点），可以管理college
public class University extends OrganizationComponent {

    List<OrganizationComponent> organizationComponentList = new ArrayList<OrganizationComponent>();

    //构造器
    public University(String name, String des){
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponentList.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponentList.remove(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    //输出university中包含的学院
    @Override
    protected void print() {
        System.out.println("==============" + getName() + "==============");
        for (OrganizationComponent org:
organizationComponentList) {
            System.out.println("==============" + org.getName() + "==============");
        }
    }
}

```

```java
//非叶子节点
public class College extends OrganizationComponent {
    //存放的是department
    List<OrganizationComponent> organizationComponentList = new ArrayList<OrganizationComponent>();

    //构造器
    public College(String name, String des) {
        super(name, des);
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponentList.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponentList.remove(organizationComponent);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    //输出university中包含的学院
    @Override
    protected void print() {
        System.out.println("==============" + getName() + "==============");
        for (OrganizationComponent org :
                organizationComponentList) {
            System.out.println("==============" + org.print() + "==============");
        }
    }
}


```

```java
//叶子节点
public class Department extends OrganizationComponent{
    public Department(String name, String des) {
        super(name, des);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public void setName(String name) {
        super.setName(name);
    }

    @Override
    public String getDes() {
        return super.getDes();
    }

    @Override
    public void setDes(String des) {
        super.setDes(des);
    }

    @Override
    protected void print() {
        System.out.println("==========" + this.getName()+ "=========");
    }
}
```

源码：HashMap



#### 九、外观模式

背景：影院管理

解决思路：定义高层接口，提供四个方法read，play，pause，end等，用来访问子系统中的一群接口

屏蔽子系统内部细节，调用端仅和高层接口进行调用



###### 外观模式

![](typora_picture\外观类UML.PNG)



 角色分析：

- 外观类：为调用端提供统一的调用接口，外观类知道那些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象

- 调用者：client外端接口的调用者

- 子系统的集合：指模块或者子系统，处理facade对象指派的任务，是功能的实际提供者

  ```java
  //伪代码--子集合类
  class DVD{
      on();
      off();
      pause();
  }
  class Popcorn{
      on();
      off();
      pop();
  }
  class Screen{
      down();
      off();
  }
  class Stereo{
      on();
      off();
      down();
  }
  class Light{
      dump();
      light();
  }
  ```

  ```java
  //伪代码 外观类
  class HomeTheaterFacade{
      DVD DVD;
      Popcorn popcorn;
      Screen screen;
      Stereo stereo;
      Light light;
      ready{
      	popcorn.on;
          popcorn.pop;
          screen.down;
          stereo.on;
          light.dump;
      }
      play{
          DVD.on;
      }
      pause{
          Dvd.pause;
      }
      off{
          DVD.off;
          popcorn.off;
          screen.up;
          light.light;
      }
      
  }
  ```

  ```java
  //伪代码 客户端
  class Client{
      main(){
          HomeTheaterFacade homeTheater;
          homeTheater.play;
          homeTheater.off;
          homeTheater.pause;
      }
  }
  ```

  

源码：MyBaits Configuration创建MetaObject



#### 十、享元模式

背景：网站展现项目，同一个网站需要在不同形似发布

享元模式：运用共享技术有效地支持大量细粒度的对象，常用于系统底层开发，解决系统的性能问题，String常量池、数据库连接池、缓冲池等

![](typora_picture\享元模式UML.PNG)



- flyWright:抽象的享元角色，是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或者实现

- concreteFlyWeight：具体的享元角色，是具体的产品类，实现抽象角色定义相关业务

- UnSharedConcreteFlyWeight：是不可共享的角色，一般不会出现在享元工厂

- FlyWeightFactory：享元工厂类，用于构建一个池容器，同时提供从池中获取对象的方法



内部状态：对象共享出来的信息

外部状态：对象得以以来的标记，随环境改变的不可共享的

![](typora_picture\享元网站UML.PNG)



```java
//网站工厂类，根据需求返回一个网站
public class WebSiteFactory {

    //集合，充当池的作用
    private HashMap<String, ConcreteWebSiteSite> pool = new HashMap<>();

    //根据网站类型，返回一个网站，如果没有就创建一个网站，并放入到池中
    public WebSite getWebSiteCategroy(String type){
        if(!pool.containsKey(type)){
            //创建网站
            pool.put(type, new ConcreteWebSiteSite(type));
        }
        return pool.get(type);
    }

    //获取网站分类的总数（池中有多少个网站类型）
    public int getWebSiteCount(){
        return pool.size();
    }
}
```



```java
public abstract class WebSite {
    public abstract void use() ;
}

```

```java
//具体的网站
public class ConcreteWebSiteSite extends WebSite {
    private String type;
    //构造器
    public ConcreteWebSiteSite(String type) {
        this.type = type;
    }

    @Override
    public void use(User user) {
        System.out.println("网站的发布形式为" + type + "；使用者：" + user.getName());
    }
}
```

```java

public class Client {
    public static void main(String[] args) {
        //创建工厂类
        WebSiteFactory webSiteFactory = new WebSiteFactory();

        //客户要以新闻形式发布的网站
        WebSite webSite = webSiteFactory.getWebSiteCategroy("新闻");
        webSite.use(new User("dandan"));

        //客户要以新闻形式发布的网站
        WebSite webSite1  = webSiteFactory.getWebSiteCategroy("新闻");
        webSite.use(new User("小鬼"));

        System.out.println(webSiteFactory.getWebSiteCount());
    }
}
```

```java
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public User(String name) {
        this.name = name;
    }
}
```

源码：integer

#### 十一、代理模式Proxy

为对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象，这样做的好处是可以在目标对象实现的基础上增强额外的功能操作，扩展对象的功能。被代理的对象可以是远程对象，创建开销大的对象或需要安全控制的对象

代理模式有不同的形式：静态代理、动态代理、Cglib代理（动态代理的另一种）



###### 静态代理：

静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象以期实现相同的接口或者是继承相同父类



需求：老师、代课老师



![](typora_picture\静态代理老师UML.PNG)

```java

//接口类，用于定义代理哪些方法
public interface ITeacherDao {
    void teach();
}
```



```java
//被代理对象
public class TeacherDao implements ITeacherDao {
    @Override
    public void teach() {
        System.out.println("TeacherDao");
    }
}
```

```java
//代理对象，通过实现接口和聚合被代理对象，实现代理的方法，
public class TeacherDaoProxy implements  ITeacherDao {
    
    private ITeacherDao targer;

    public TeacherDaoProxy(ITeacherDao targer) {
        this.targer = targer;
    }

    @Override
    public void teach() {
        System.out.println("TeeacherDaoProxy");
        targer.teach();
    }
}
```

```java
public class Client {
    public static void main(String[] args) {
        TeacherDao teacherDao = new TeacherDao();
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);
        teacherDaoProxy.teach();
    }
}
```

优点：不修改目标对象功能的情况下，实现了功能的拓展

确定：代理对象需要与目标对象实现一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都需要进行维护

###### 动态代理

代理对象不需要实现接口，但是目标对象要实现接口

代理对象的生成是利用JDK的API动态的在内存中构建代码，也叫JDK代理、接口代理

java.lang.reflect.Proxy包中 newProxyInstance方法 Loader，interfaces， invocationHandler三个参数



![](typora_picture\动态代理老师UML.PNG)

```java
public interface ITeacherDao {

  public void teach();

  public void teach2(int i);
}

```

```java
public class TeacherDao implements ITeacherDao {
    @Override
    public void teach() {
        System.out.println("老师在授课");
    }

    @Override
    public void teach2(int i) {
        System.out.println("老师在授课" + i);
    }
}

```

```java
public class ProxyFactory {

    //维护一个目标对象
    private Object target;

    //构造器对targer进行初始化
    public ProxyFactory(Object target) {
        this.target = target;
    }

    //给目标对象生成代理对象
    public Object getProxyInstance(){
        //说明：
        //public static Object newProxyInstance(ClassLoader loader,
        //                                     Class<?>[] interfaces,
        //                                    InvocationHandler h)
        //1、classloadeer：执行当前目标对象使用的类加载器，获取类加载器的方法（固定）
        //2、class<?>[] interfaces：目标对象实现的接口类型，使用泛型方法确认类型
        //3、InvocationHandler ：事情处理，执行目标对象的方法是，会触发事情处理其方法，
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("JDK动态代理");
                Object obj = method.invoke(target,args);
                System.out.println("JDK动态代理");
                return obj;

            }
        });
    }
}

```

```java

public class Client {
    public static void main(String[] args) {
        //创建目标对象
        ITeacherDao target = new TeacherDao();

        //给目标对象，创建代理对象
        ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance();

        System.out.println("proxyInstance" + proxyInstance.getClass());


        //通过代理对象，调用目标对象的方法
        proxyInstance.teach();
        proxyInstance.teach2(2);
    }
}
```



###### Cglib代理

静态代理和JDK代理都要求目标对象实现一个接口，但有时候目标对象是一个单独的对象，没有实现任何的接口，这时候可使用目标对象子类来实习那代理

在内存中构建一个子类对象从而实现对目标对象功能扩展

底层是通过使用字节码处理框架ASM来转换字节码并生成新的类（所以被代理被必须可以继承，被代理的方法必须可以继承）



 ![](typora_picture\CGlib代理老师UML.PNG)



```java
public class TeacherDao {
    public void teacher(){
        System.out.println("老师授课");
    }
}

```

```java
public class ProxyFactory implements MethodInterceptor {
    //维护一个目标对象
    private Object target;

    //构造器，传入被代理对象
    public ProxyFactory(Object target) {
        this.target = target;
    }

    /**
     * 返回代理对象，是targer的代理对象
     * @return
     */
    public Object getProxyInstance(){
        //1、创建工具类
        Enhancer enhancer = new Enhancer();
        //2、设置父类
        enhancer.setSuperclass(target.getClass());
        //3、设置回调函数
        enhancer.setCallback(this);
        //4、创建子类对象，即代理对象
        return enhancer.create();

    }
    //重写intercept方法，会调用目标对象的额方法
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("cglib代理模式");
        Object returnVal = method.invoke(target, args);
        System.out.println("结束");

        return returnVal;
    }
}

```

```java
public class Client {

    public static void main(String[] args) {
        TeacherDao teacher = new TeacherDao();
        TeacherDao factory = (TeacherDao)new ProxyFactory(teacher).getProxyInstance();
        factory.teacher();

    }
}
```



#### 十二、模板方法

制作豆浆：选材，加料，浸泡，放豆浆机；

流程都一样，豆子不一样

模板模式：行为型模式，抽象类中公开定义执行他的方法的模板，子类按需重写，调用将以抽象类中定义的方法进行。

```java
//伪代码：
class AbstractModel{
    //定义了操作顺序
    void templete(){
        operate;
        operate2;
    };
    //流程，可以抽象也可以非抽象
    operation();
    operation1();
    operation2();
}
```



```java
ConcreteClass{
    operation(){};
    operation1(){};
    operation2(){};
}
```

```java
class Client{
    main{
    ConcreteCalss concrete = new concreteClass();
    concrete.operation;    
    }
}
```

//通过模板中的钩子方法可以选择是否增加配料，子类重写勾子方法（可以不重写），子类空实现，父类跳过该方法

源码：SpringIOC



#### 十三、命令模式

背景：不同智能家电，使用同一个app进行控制，

命令模式（command pattern）：请求发送者与请求接收者解耦，让对象之间的调用关系更加灵活，实现解耦。将请求封装成对象，一边使用不同的参数表示不同的请求，命令模式支持可撤销的操作。

在软件设计中，经常需要向某些对象发送请求，但并不知道接收者是谁，也不知道被请求的操作是哪些，只需要在程序运行时指定具体的请求接收者即可，此时使用命令模式

![](typora_picture\命令模式UML.PNG)

invoker：调用者

receiver：被调用者

Command：命令，需执行的命令都在这个接口中定义，

ConcreteCommand：将一个接收者对象与一个动作绑定，调用接受者相应的操作，实现execute

Command：抽象命令



使用命令模式完成智能家电需求

![](typora_picture\命令模式实现智能家电UML.PNG)



```java
//创建命令接口
public interface Command {
    //执行动作（操作）
    public void execute();
    //撤销动作（操作）
    public void undo();
}
```

```java
//当在调用空命令时，对象什么都不做
//这也是一种设计模式，可以省掉对空的判断
public class NoCommand implements Command {
    @Override
    public void execute() {
    }

    @Override
    public void undo() {
    }
}

```

```java
//目标对象：灯泡
public class LightReceiver {

    public void on(){
        System.out.println("电灯打开   ");
    }
    public void off(){
        System.out.println("电灯关闭  ");
    }
}

```

```java
//目标对象TV
public class TVReceiver {

    public void on(){
        System.out.println("TV打开   ");
    }
    public void off(){
        System.out.println("TV关闭  ");
    }
}

```

```java

//开指令
public class LightOffCommand implements  Command {

    //聚合LightReceiver
    LightReceiver light;

    public LightOffCommand(LightReceiver light) {
        super();
        this.light = light;
    }

    @Override
    public void execute() {
        //调用接收者的方法
        light.off();
    }

    @Override
    public void undo() {
        //调用接受者的方法
        light.on();
    }
}
```

```java

//电视关指令
public class LightOnCommand implements Command {

    //聚合LightReceiver
    LightReceiver light;

    public LightOnCommand(LightReceiver light) {
        super();
        this.light = light;
    }

    @Override
    public void execute() {
        //调用接收者的方法
        light.on();
    }

    @Override
    public void undo() {
        //调用接受者的方法
        light.off();
    }
}
```

```java
//TV关命令
public class TVOffCommand implements Command{
    //聚合LightReceiver
    TVReceiver light;

    public TVOffCommand(TVReceiver light) {
        super();
        this.light = light;
    }

    @Override
    public void execute() {
        //调用接收者的方法
        light.off();
    }

    @Override
    public void undo() {
        //调用接受者的方法
        light.on();
    }
}
```

```java
//TV开命令
public class TVOnCommand implements Command{
    //聚合LightReceiver
    TVReceiver TV;

    public TVOnCommand(TVReceiver TV) {
        super();
        this.TV = TV;
    }

    @Override
    public void execute() {
        //调用接收者的方法
        TV.off();
    }

    @Override
    public void undo() {
        //调用接受者的方法
        TV.on();
    }
}
```

```java

//遥控器对象
public class RemoteController {

    Command[] onCommands;
    Command[] offCommands;

    Command undoCommand;

    public RemoteController() {
        onCommands = new Command[5];
        offCommands = new Command[5];

        for (int i = 0; i < 5; i++) {
            onCommands[i] = new NoCommand();
            offCommands[i] = new NoCommand();
        }
    }

    //给按钮设置命令
    public void setCommand(int no, Command onCommand, Command offCommand) {
        onCommands[no] = onCommand;
        offCommands[no] = offCommand;
    }

    //按下开按钮
    public void onBottonWassPushed(int no) {
        //找到按下的开的按钮，并调用对应的方法
        onCommands[no].execute();
        //记录这次的操作，用于撤销
        undoCommand = onCommands[no];
    }

    //按下关按钮
    public void offBottonWassPushed(int no) {
        //找到按下的开的按钮，并调用对应的方法
        offCommands[no].execute();
        //记录这次的操作，用于撤销
        undoCommand = offCommands[no];
    }

    //按下撤销按钮
    public void undoButtonWasPushed(){
        undoCommand.undo();
    }

}
```

```java
public class Client {
    public static void main(String[] args) {
        //使用命令设计模式完成通过遥控器对电灯的操作
        //创建电灯的对象
        LightReceiver lightReceiver = new LightReceiver();

        //创建TV对象
        TVReceiver tv = new TVReceiver();

        //创建电灯的开关命令
        LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);
        LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);

        //创建TV的开关命令
        TVOnCommand TVOn = new TVOnCommand(tv);
        TVOffCommand TVOff = new TVOffCommand(tv);

        //创建遥控器
        RemoteController remoteController = new RemoteController();

        //给遥控器设置命令，
        remoteController.setCommand(0,lightOnCommand,lightOffCommand);

        remoteController.setCommand(1,TVOn, TVOff);

        System.out.println("----------灯开------------");
        remoteController.onBottonWassPushed(0);

        System.out.println("----------灯关------------");
        remoteController.offBottonWassPushed(0);

        System.out.println("----------灯撤销------------");
        remoteController.undoButtonWasPushed();

        System.out.println("----------TV关------------");
        remoteController.offBottonWassPushed(1);

        System.out.println("----------TV撤销------------");
        remoteController.undoButtonWasPushed();
    }
}
```

源码：JDBCTemplete



注意事项：发起请求的对象和执行请求的对象解耦，命令对象把接收者和命令聚合在一起，如果把命令对象放到队列，可以对线程的执行命令，且容易实现命请求的撤销和重做。开闭原则友好

不足：命令类较多，增加了系统的复杂度

空命令模式省去了判空

#### 十四、访问者模式

需求：测评系统，评委分为男女，给歌手打分结果分为成功失败

访问者模式：封装一些作用域某种数据结构的个元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。将数据结构和数据操作分离

基本原理：在被访问的类里面加一个对外提供访问者的接口

![](typora_picture\访问者模式UML.PNG)

- visitor:抽象访问者，为改对象结构中的ConcreteElement的每一个类声明一个visit操作
- ConcreteVisitor：是具体的访问者，实现每个由visitor声明的操作，是每个操作实现的部分
- ObjectStructure：能枚举他的元素，可以提供一个高层的接口，用来允许访问者访问元素
- Element：定义了一个accept方法，可以接收访问者对象
- ConcreteElement：具体元素，实现了accept方法

![](typora_picture\访问者者模式完成打分的需求UML.PNG)

```java
public abstract class Person {

    public abstract void accept(Action action);
}
```

```java
//这点使用到了双分派，首先在客户端程序中，将具体状态作为参数传递Woman中
//dier：woman类调用作为参数的具体方法中getWomanResult,同时将自己作为参数传入，作为第二次分派
public class Woman extends Person {
    @Override
    public void accept(Action action) {
        action.getWomanResult(this);
    }
}
```

```java
public class Man extends Person {
    @Override
    public void accept(Action action) {
        action.getManResult(this);
    }
}
```

```java
public abstract class Action {

    //得到男性的测评
    public abstract  void getManResult(Man man);

    //得到女性的测评
    public abstract void getWomanResult(Woman woman);
}

```

```java
public class Fail extends Action {
    @Override
    public void getManResult(Man man) {
        System.out.println("男人给评价：失败");
    }

    @Override
    public void getWomanResult(Woman woman) {
        System.out.println("女人给评价：失败");
    }
}

```

```java

public class Success extends Action {
    @Override
    public void getManResult(Man man) {
        System.out.println("男人给评价：成功");
    }

    @Override
    public void getWomanResult(Woman woman) {
        System.out.println("女人给评价：成功");
    }
}
```

```java
public class ObjectStructure {

    //维护了一个集合
    private List<Person> personList = new LinkedList<>();

    public  void  attach(Person person){
        personList.add(person);
    }

    public void detach(Person person){
        personList.remove(person);
    }

    public void display(Action action){
        for (Person p: personList
             ) {
            p.accept(action);
        }
    }
}

```

```java
public class Client {

    public static void main(String[] args) {
        //创建OBjStructure
        ObjectStructure objectStructure = new ObjectStructure();

        objectStructure.attach(new Man());
        objectStructure.attach(new Man());
        objectStructure.attach(new Man());
        objectStructure.attach(new Woman());

        Success success = new Success();
        objectStructure.display(success);
    }
}
```

PS:拓展状态就多一个继承Ation的类，拓展人类就多一个结成Person的类

细节：符合单一职责原则，方便推展，适用于数据集合相对稳定的系统

缺点：具体元素对访问者公布细节，访问者关注了其他类内部细节，违反了迪米特

访问者依赖的是具体元素，而不是抽象元素，违反了依赖倒转

#### 十五、迭代器模式

需求：学校-学院-系，实现遍历（每个学院可能由不同数据结构保存系）

迭代器模式：行为型模式，可以使用一致的方法遍历集合元素即使集合不是相同的数据结构、

![](typora_picture\迭代器模式UML.PNG)

Iterator：系统提供，hasNext，next，remove

ConcreteIterator:具体的迭代类

Aggregrate：一个统一的聚合接口，将客户端和具体聚合解耦

ConcreteAggreage：具体的聚合持有对象集合，并提供一个方法，返回一个迭代器，该迭代器可以遍历集合

Client：客户端，通过Iterator和Aggreate依赖子类

###### 问题：和外观模式有啥区别？

![](typora_picture\迭代器模式完成需求UML.PNG)

```java
public interface College {

    public String getName();
    public void addDepartment(String name, String desc);

    public Iterator createIterator();
}

```

```java
public class Depetment {
    private String name;
    private String desc ;

    public Depetment(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
}
```

```java
public class InfoCollegeIterator implements Iterator {
    List<Depetment> depetmentList;

    int index = -1;

    public InfoCollegeIterator(List<Depetment> depetmentList) {
        this.depetmentList = depetmentList;
    }

    @Override
    public boolean hasNext() {
        if(index >= depetmentList.size() -1){
            return false;
        }else{
            index += 1;
            return true;
        }
    }

    @Override
    public Object next() {
        return depetmentList.get(index);
    }

    @Override
    public void remove() {

    }
}
```

```java
public class InfoCollege implements College {

    List<Depetment> depetmentList ;
    @Override
    public String getName() {
        return "信息工程学院";
    }

    @Override
    public void addDepartment(String name, String desc) {
        Depetment depetment = new Depetment(name,desc);
        depetmentList.add(depetment);
    }

    @Override
    public Iterator createIterator() {
        return new InfoCollegeIterator(depetmentList);
    }

    public InfoCollege() {
        depetmentList = new ArrayList<>();
        addDepartment("信息安全专业","xinxidesc");
        addDepartment("专业1","专业1desc");
        addDepartment("专业2","专业2desc");
    }


}
```

```java
public class ComputerCollegeIterator implements Iterator {
    //需要知道department是怎样的方式存放
    Depetment[] depetments;
    int position = 0;//便利的位置

    public ComputerCollegeIterator(Depetment[] depetments) {
        this.depetments = depetments;
    }

    @Override
    public boolean hasNext() {
        if(position >= depetments.length || depetments[position] == null ){
            return false;
        }else{
            return true;
        }
    }

    @Override
    public Object next() {
        Depetment depetment =  depetments[position];
        position += 1;
        return depetment;
    }

    @Override
    public void remove() {

    }
}
```

```java
public class ComputerCollege implements College {

    Depetment[] departments;
    int numOfDepartment = 0;//数组对象个数

    public ComputerCollege() {
        this.departments = new Depetment[5];
        addDepartment("java","java");
        addDepartment("PHP","java");
        addDepartment("PYthon","java");
    }

    @Override
    public String getName() {
        return "计算机学院";
    }

    @Override
    public void addDepartment(String name, String desc) {
        Depetment depetment = new Depetment(name,desc);
        departments[numOfDepartment] = depetment;
        numOfDepartment += 1;
    }

    @Override
    public Iterator createIterator() {
        return new ComputerCollegeIterator(departments);
    }
}
```

```java
public class OutPutImpl {

    //学院集合
    List<College> collegeList;

    public OutPutImpl(List<College> collegeList) {
        this.collegeList = collegeList;
    }

    //遍历学院，调用printDepartment输出各个学院的系
    public void printCollege(){
        //从collegeList中取出所有的学院
        Iterator<College> iterator = collegeList.iterator();
        while(iterator.hasNext()){
            College college = iterator.next();
            System.out.println("========学院名称" + college.getName());
            printDepartment(college.createIterator());
        }
    }

    //学院输出系

    public void printDepartment(Iterator iterator){
        while (iterator.hasNext()){
            Depetment depetment = (Depetment) iterator.next();
            System.out.println(depetment.getName());
        }
    }
}

```

```java
public class Client {
    public static void main(String[] args) {
        //创建学院
        List<College> collegeList = new ArrayList<>();
        ComputerCollege computerCollege = new ComputerCollege();
        InfoCollege infoCollege = new InfoCollege();

        collegeList.add(computerCollege);
        collegeList.add(infoCollege);

        OutPutImpl outPut = new OutPutImpl(collegeList);
        outPut.printCollege();
    }
}
```



![](typora_picture\Iterator源码UML.PNG)

优点：统一方法遍历对象，隐藏了聚合的内部结构，客户端要遍历集合只能取到迭代器，而不知道聚合的具体组成；一个类应该只有一个引起变化的原因（单一职责原则），把迭代器分开，就是把管理对象集合和遍历对象集合的责任分开，集合改变只影响聚合对象，遍历改变只影响迭代器

缺点：每个聚合对象都有一个迭代器，迭代器类超多

#### 十六、观察者模式

需求：天气预报，气象站测量温度、适度、气压，设计开放api，数据更新要能实时通知第三方

观察者模式：对象之间多对一依赖的一种设计方案，被依赖对象为Subject，依赖对象为Observer，Sub通知Obs变化。

![](typora_picture\观察者模式解决天气推送需求UML.PNG)

```java
//多，观察者
public interface Subject {

    public void registerObserver(Observer o);
    public void removeObservier(Observer o);
    public void notifyObservers();
}

```

```java
//被观察者接口
public interface Observer {

    public void update(float temperature, float pressure,float humidity);
}

```

```java
/**
 * 类是核心
 * 1、包含最新的天气情况信息
 * 2、含有观察者集合，使用ArrayList管理
 * 3、当数据由更新时，就主动调用ArrayList，通知所有接入方就看到最新的信息
 */
public class WeatherData implements Subject{
    private float temperature;
    private float pressure;
    private float humidity;
    //观察者集合
    private ArrayList<Observer> observers;

    public WeatherData(){
        observers = new ArrayList<>();
    }
    //注册一个观察者
    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    //一处一个观察者
    @Override
    public void removeObservier(Observer o) {
        if(observers.contains(o)) {
            observers.remove(o);
        }
    }

    //遍历所有观察者并通知
    @Override
    public void notifyObservers() {
        for (int i = 0; i < observers.size() ; i++){
            observers.get(i).update(this.temperature,this.pressure,this.humidity);
        }

    }
    
    public void setData(float temperature, float pressure ,float humidity){
        this.humidity = humidity;
        this.temperature = temperature;
        this.pressure = pressure;
        dataChange();
    }

    private void dataChange() {
        //调用接收方的daaChanget
        notifyObservers();
    }
}
```

```java
private float temperature;
    private float pressure;
    private float humidity;

    @Override
    public void update(float temperature, float pressure, float humidity) {
        this.humidity = humidity;
        this.pressure = pressure;
        this.temperature = temperature;
        display();
    }
    //
    public void display(){
        System.out.println("==" + temperature + "==");
        System.out.println("==" + pressure + "==");
        System.out.println("==" + humidity + "==");

    }
```

```java
public class Client {
    public static void main(String[] args) {
        //创建weatherdata
        WeatherData weatherData = new WeatherData();

        CurrentConditions currentConditions = new CurrentConditions();
        Baidu baidu = new Baidu();
        weatherData.registerObserver(currentConditions);
        weatherData.registerObserver(baidu);
        System.out.println("----------");
        weatherData.setData(10,10,10);
    }
}a
```



源码：JDK Observable



#### 十七、中介者模式

中介者模式：行为模式，用一个中介对象来封装一系列的对象交互，中介者使各个对象不需要显示地相互引用，从而使其耦合松散，可以独立的改变他们之间的交互

![](typora_picture\中介者UML.PNG)

1、mediator是抽象中介者，定义了同事对象到中介者对象的接口

2、colleague是抽象同时类

3、ConcreteMediator是具体的中介者对象，四线后向方法，需要所有的具体同时类（以一个集合来管理HashMap），并接受某个对象消息完成相应的任务

4、ConcreteCollegue具体的同时类，有多个，每个同时只知道自己的行为，，但他们都依赖中介者对象



![](typora_picture\中介者模式完成智能家庭UML.PNG)

1、创建concreteMediator

2、创建各个同事类，Alarm、、、

3、创建同时类对象的时候，直接通过构造器加入到concreteMediator的colleagueMap中，

4、同事类对象可以调用getmessage方法最终会调用concreteMeditor的getMessage方法

5、getMessage会根据接收到的同事对象发乎的详细来协调同事类对象

6、getMessage是核心方法。



#### 十八、备忘录模式

背景：游戏角色状态恢复

备忘录模式：行为模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 这样以后就可以将该对象回恢复原先保存的对象状态。

![](typora_picture\备忘录模式UML.PNG)

originator:需保存的对象

Memento：备忘录对象，Originator的呢不状态

caretaker：守护对象，负责保存多个备忘录对象，可以使用集合管理



 ```java

public class Memento {

    private int vit;
    private int def;

    public Memento(int vit, int def) {
        super();
        this.vit = vit;
        this.def = def;
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }
}

 ```

```java
//守护者对象，保存游戏角色的状态
public class Caretaker {
    //如果只保存一次
    private Memento memento;

    //如果保存多次
//    private ArrayList<Memento> mementos;

    //如果保存多次
//    private HashMap<String, ArrayList<Memento>> rolesMemento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
```

```java
public class GameRole {

    private int vit;
    private int def;

    // 创建memento，根据当前的状态得到
    public Memento createMemento(){
        return new Memento(vit, def);
    }

    //从备忘录对象，恢复GameROle
    public void recoverGameRoleFromMemento(Memento memento){
        this.def = memento.getDef();
        this.vit = memento.getVit();
    }

    //显示当前游戏角色的状态
    public void display(){
        System.out.println("状态vit" + this.vit+"状态def" + this.vit);
    }

    public int getDef() {
        return def;
    }

    public void setDef(int def) {
        this.def = def;
    }

    public int getVit() {
        return vit;
    }

    public void setVit(int vit) {
        this.vit = vit;
    }
}
```

```java
public class Client {                                       
    public static void main(String[] args) {                
        GameRole gameRole = new GameRole();                 
        gameRole.setVit(100);                               
        gameRole.setDef(100);                               
                                                            
        System.out.println("大战前的状态");                       
                                                            
        gameRole.display();                                 
                                                            
        Caretaker caretaker = new Caretaker();              
        caretaker.setMemento(gameRole.createMemento());     
                                                            
        System.out.println("大战");                           
        gameRole.setDef(30);                                
        gameRole.setVit(30);                                
                                                            
        gameRole.display();                                 
                                                            
        System.out.println("恢复");                           
                                                            
        gameRole.recoverGameRoleFromMemento(caretaker.getMem
        gameRole.display();                                 
    }                                                       
}                                                           
```











#### 十九、解释器模式

案例：通过解释器模式 实现加减运算

解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子。

![](typora_picture\解释器模式UML.PNG)

conrext:环境角色，含有解释器之外的全局信息

abstractExpression：抽象表达式，声明抽象的解释操作。这个方法为抽象语法树中所有的节点所共享

terminalExpression：终结符表达式，实现与文法中的终结符相关的解释操作

NonTerminalExpression：非终结表达式，为文法中的非终结符实现解释操作。

输入context和terminalExpression信息，通过Client输入即可

###### 使用解释器模式实现加减运算

![](typora_picture\解释器模式完成加减操作UML.PNG)

源码：SpelExpressionParser









#### 二十、状态模式

背景：App抽奖扣除积分

![](typora_picture\状态模式_App抽奖扣积分需求.PNG)

状态模式：解决对象在多种状态转换时，需要对外输出不同行为的问题，状态和问题是一一对应的，状态之间可以相互转换。同一个对象，内在状态改变时，允许改变行为。

![](typora_picture\状态模式UML.PNG)

COntext类为环境角色，用于维护ConcreteState实例，这个实例定义当前的状态，

State是抽象的状态角色，定义一个接口封装与Context的一个特定接口相关行为

ConcreState具体的状态角色，每个子类实现一个与Context的一个状态相关的行为（定义的是该状态的行为）

![](typora_picture\状态模式完成APP抽奖需求UML.PNG)

源码：









#### 二十一、策略模式

背景：鸭子很多种，有很多行为，显示 鸭子信息

策略模式：定义算法，分别封装，可以相互替换，让算法的变化独立于使用算法的客户。

![](typora_picture\策略模式UML.PNG)



Context拥有成员变量Strategy或者多个，需要使用到哪个策略就在构造器中指定。

![](typora_picture\策略模式实现鸭子需求UML.PNG)



源码：Arrays



变化的部分就是策略，不变的部分就是使用者，多用组合/聚合，少用继承，使用行为类组合，更有弹性。

缺点：每个策略都有一个类，类数目庞大



#### 二十二、职责链模式

需求：采购审批，根据不同金额，审批人级别不同

职责链：为请求创建了一个接收者对象的链，每个接收者都包含另一个接收者的引用，如果一个对象不能处理该请求，九八相同的请求传递给下一个接收者，这种模式对请求的发送者和接收者进行解耦，属于行为型模式。

![](typora_picture\职责链模式UML.PNG)

1、Handler：抽象的处理者，定义了处理请求的接口（方法），包含有另一个handler对象，

2、Concretehandler：具体的处理者，可以访问下一个处理者，能处理处理，不能处理就传递给它的下一个处理者

3、含有很多属性，表示一个请求



源码：SpringMVC























































